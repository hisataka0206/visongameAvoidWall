<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç≠„É°„Éù -KiMePose-</title>
    <!-- MediaPipe Tasks Vision (Loaded dynamically in module) -->

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video {
            display: none;
            /* Hide raw video */
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-fit: cover;
            /* transform: scaleX(-1); REMOVED - Handled in JS */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-weight: bold;
        }

        #score-display {
            color: #ffcc00;
        }

        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 20px;
            border: 4px solid #fff;
        }

        h1 {
            font-size: 4rem;
            margin: 0 0 20px 0;
            color: #ff0055;
            text-transform: uppercase;
            letter-spacing: 5px;
            transform: skew(-10deg);
        }

        p {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        .instruction-text {
            font-size: 2.5rem;
            color: #ffcc00;
            margin: 20px 0;
            font-weight: bold;
            animation: flash 1s infinite alternate;
        }

        @keyframes flash {
            from {
                opacity: 1;
            }

            to {
                opacity: 0.5;
            }
        }

        /* Disclaimer Styling */
        .disclaimer-box {
            margin-top: 30px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            text-align: left;
            border: 1px solid #555;
            max-width: 700px;
            font-size: 0.9rem;
        }

        .disclaimer-item {
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .disclaimer-item:last-child {
            margin-bottom: 0;
        }

        .disclaimer-icon {
            font-size: 1.2rem;
            margin-right: 5px;
            vertical-align: middle;
        }

        .text-safe {
            color: #4db8ff;
        }

        .text-warn {
            color: #ff5555;
        }

        .text-highlight {
            font-weight: bold;
            color: #fff;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>

        <div id="ui-layer">
            <div id="hud">
                <div id="score-display">SCORE: 0</div>
                <div id="lives-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
        </div>

        <!-- Start / Game Over Screen -->
        <div id="message-overlay">
            <h1 id="title-text">„Ç≠„É°„Éù</h1>
            <p id="status-text">Loading Assets...</p>
            <div id="start-instruction" class="instruction-text" style="display:none;">LOADING...</div>

            <div class="disclaimer-box">
                <div class="disclaimer-item text-safe">
                    <span class="disclaimer-icon">üîí</span>
                    <span class="text-highlight">ÂÆâÂøÉË®≠Ë®à:</span>
                    „Ç´„É°„É©Êò†ÂÉè„Å®È™®Ê†ºÊé®ÂÆö„ÅÆÂá¶ÁêÜ„ÅØ„Åô„Åπ„Å¶„É¶„Éº„Ç∂„Éº„ÅÆPCÂÜÖÔºà„É≠„Éº„Ç´„É´Ôºâ„ÅßÂÆåÁµê„Åó„Åæ„Åô„ÄÇ
                    Êò†ÂÉè„Åå„Çµ„Éº„Éê„Éº„Å´ÈÄÅ‰ø°„Éª‰øùÂ≠ò„Åï„Çå„Çã„Åì„Å®„ÅØ‰∏ÄÂàá„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
                </div>
                <div class="disclaimer-item text-warn">
                    <span class="disclaimer-icon">‚ö†Ô∏è</span>
                    <span class="text-highlight">ÂÆâÂÖ®‰∏ä„ÅÆÊ≥®ÊÑè:</span>
                    ‰Ωì„ÇíÂ§ß„Åç„ÅèÂãï„Åã„Åô„Ç≤„Éº„É†„Åß„Åô„ÄÇ
                    <strong>Âë®Âõ≤„ÅÆÂÆâÂÖ®„ÇíÂçÅÂàÜ„Å´Á¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</strong>
                    „Éó„É¨„Ç§‰∏≠„ÅÆÊÄ™Êàë„ÇÑÁâ©Êêç„Å´„Å§„ÅÑ„Å¶„ÄÅÈñãÁô∫ËÄÖ„ÅØË≤¨‰ªª„ÇíË≤†„ÅÑ„Åæ„Åõ„Çì„ÄÇ
                </div>
                <div class="disclaimer-item text-safe"
                    style="margin-top: 10px; border-top: 1px solid #777; padding-top: 5px;">
                    <span class="disclaimer-icon">‚ÑπÔ∏è</span>
                    <span class="text-highlight">ÂìÅË≥™ÊîπÂñÑ:</span>
                    „Ç≤„Éº„É†„ÅÆÂìÅË≥™Âêë‰∏ä„ÅÆ„Åü„ÇÅ„ÄÅ„Éó„É¨„Ç§‰∏≠„ÅÆ„Ç≠„ÉºÊìç‰Ωú„É≠„Ç∞Á≠â„ÇíÂåøÂêç„ÅßÂèéÈõÜ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
                    ÂÄã‰∫∫„ÇíÁâπÂÆö„Åô„ÇãÊÉÖÂ†±„ÅØÂê´„Åø„Åæ„Åõ„Çì„ÄÇ
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- 1. CONFIG OBJECT ---
        const GAME_CONFIG = {
            poses: ['Y', 'I', 'SQUAT', 'X', 'T', 'FLAMINGO', 'SUMO', 'KICK'],
            hitThreshold: 5,
            initialSpeed: 5.0,       // Wall speed
            // maxSpeed removed (Unlimited)
            speedIncrement: 1.0,     // Speed up per clear
            spawnInterval: 2000,     // Time between walls (Waiting period) in ms
            judgementFrameCount: 5,  // Not strictly used with current Z-logic, but conceptually good
            wallStartZ: 100,         // Start distance
            wallOpacity: 0.8         // Wall Image Opacity (0.0 to 1.0)
        };

        // --- CALORIE CONFIG ---
        const CALORIE_CONFIG = {
            PER_PIXEL: 0.0005, // kcal per pixel movement
            POSE_INTENSITY: {
                'SQUAT': 0.12, 'SUMO': 0.12,
                'KICK': 0.08, 'FLAMINGO': 0.08, 'Y': 0.08, 'X': 0.08, 'T': 0.08,
                'I': 0.05, 'DEFAULT': 0.05
            }
        };

        const EFFECT_DURATION = 60; // Frames (approx 1 sec)

        // --- GLOBALS ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const startInstruction = document.getElementById('start-instruction');
        const statusText = document.getElementById('status-text');
        const titleText = document.getElementById('title-text');
        const messageOverlay = document.getElementById('message-overlay');
        const scoreDisplay = document.getElementById('score-display');
        const livesDisplay = document.getElementById('lives-display');

        // Game State
        let gameState = 'LOADING'; // LOADING, MENU, PLAYING, GAMEOVER
        let subState = 'WAIT';     // WAIT, ACTION, RESULT (Managed within PLAYING)

        let score = 0;
        let lives = 3;
        let lastTime = 0;

        let currentSpeed = GAME_CONFIG.initialSpeed;
        let spawnTimer = 0; // ms

        let currentWall = null;
        let latestResults = null;

        // --- TEST MODE STATE ---
        let isTestMode = false;
        let testState = {
            laneOrder: [-1, 0, 1],
            currentLaneIndex: 0,
            poseIndex: 0
        };

        // --- EFFECT STATE ---
        let effectState = {
            type: null,        // 'clear', 'miss', or null
            timer: 0,          // Frames
            shakeIntensity: 0  // Pixel offset
        };

        // --- CALORIE STATE ---
        let totalMoveDistance = 0;
        let poseDurationMap = {}; // { 'SQUAT': 0.0, ... }
        let lastNoseX = null;
        let nextPoseType = null; // Decided at start of WAIT

        // --- MEDIAPIPE TASKS ---
        let poseLandmarker = undefined;
        let drawingUtils = undefined;
        let POSE_CONNECTIONS = null;
        let lastVideoTime = -1;

        // --- IMGAES ---
        const IMAGES = {};
        const IMAGE_SOURCES = {
            'BASE': './wall/wall50.png',
            'Y': './wall/wallY50tr.png',
            'I': './wall/wallI50tr.png',
            'SQUAT': './wall/wallSquat50tr.png',
            'X': './wall/wallX50tr.png',
            'T': './wall/wallT50tr.png',
            'FLAMINGO': './wall/wallFlamingo50tr.png',
            'SUMO': './wall/wallSumo50tr.png',
            'KICK': './wall/wallKick50tr.png'
        };
        let assetsLoaded = false;
        let visionLoaded = false;

        // --- SOUND ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'bgm-start') {
                // Placeholder
            } else if (type === 'success') {
                osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'crash') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.4);
            }
        }

        // --- POC LOGGING ---
        const GAS_URL = "https://script.google.com/macros/s/AKfycbxeJqv6X1k6V3o9HkMGSe7I-Td0F0ry8MgN3_NtLkEn1aYfapXYND5nUYl8PCamvu8ANA/exec";
        const GAME_NAME = "AvoidWall_v1";
        const SESSION_ID = "sesswall_" + Math.random().toString(36).substr(2, 9);

        function sendLog(data) {
            console.log(`[PoC Log]`, data);

            let logKey = "";
            let logNote = "";

            if (data.type === 'key') {
                logKey = data.key;
                logNote = data.note || "";
            } else if (data.type === 'erroneous_input') {
                logKey = data.key;
                logNote = `ERRONEOUS (Exp: ${data.expected.join(',')})`;
            } else if (data.type === 'game_over') {
                logKey = "GAME_OVER";
                logNote = `Score: ${data.score}, Level: ${data.level && data.level.toFixed ? data.level.toFixed(1) : data.level}`;
            } else if (data.type === 'event') {
                logKey = data.event.toUpperCase(); // CLEAR / MISS
                logNote = `Pose: ${data.pose}, Lane: ${data.lane}, Score: ${data.score || ""}, Lives: ${data.lives || ""}`;
            } else {
                logKey = data.type || "UNKNOWN";
                logNote = JSON.stringify(data);
            }

            const payload = {
                gameName: GAME_NAME,
                session: SESSION_ID,
                timestamp: new Date().toISOString(),
                key: logKey,
                note: logNote
            };

            fetch(GAS_URL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify(payload)
            }).catch(e => console.error("Log Error:", e));
        }

        function sendKeyLog(keyName, note = "") {
            sendLog({ type: 'key', key: keyName, note: note });
        }

        // Global Key Listener
        window.addEventListener('keydown', (e) => {
            const key = e.key;

            let expected = [];
            if (gameState === 'MENU' || gameState === 'GAMEOVER') {
                expected = ['s', 'S', 't', 'T'];
            }

            if (expected.length > 0 && !expected.includes(key)) {
                sendLog({
                    type: 'erroneous_input',
                    key: key,
                    state: gameState,
                    expected: expected,
                    description: "User pressed unexpected key for current screen."
                });
                return;
            }

            sendKeyLog(key);

            if ((key === 's' || key === 'S')) {
                if (gameState === 'MENU' || gameState === 'GAMEOVER') {
                    startGame();
                }
            }

            // Test Mode Toggle
            if ((key === 't' || key === 'T')) {
                if (gameState === 'MENU' || gameState === 'GAMEOVER') {
                    isTestMode = !isTestMode;
                    const modeText = isTestMode ? "TEST MODE" : "NORMAL MODE";
                    const color = isTestMode ? "#00FFFF" : "#FFCC00";

                    const originalTitle = titleText.innerText;
                    statusText.innerText = `MODE SWITCHED: ${modeText}`;
                    statusText.style.color = color;

                    titleText.style.color = color;
                    setTimeout(() => {
                        titleText.style.color = "#ff0055";
                        if (gameState === 'MENU') statusText.innerText = "Are you ready?";
                    }, 1000);
                }
            }
        });

        // --- MEDIA PIPE INITIALIZATION ---
        async function setupMediaPipe() {
            const { PoseLandmarker, FilesetResolver, DrawingUtils: MPDrawingUtils } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js");

            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );

            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numPoses: 5,
                minPoseDetectionConfidence: 0.5,
                minPosePresenceConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            drawingUtils = new MPDrawingUtils(canvasCtx);
            POSE_CONNECTIONS = PoseLandmarker.POSE_CONNECTIONS;

            visionLoaded = true;
            console.log("MediaPipe Pose Landmarker Loaded");
            checkReady();
        }

        setupMediaPipe();

        // Start Camera
        const enableWebcam = () => {
            if (!poseLandmarker) {
                console.log("Wait for poseLandmarker to load before enabling webcam");
                return;
            }

            const constraints = {
                video: { width: 1280, height: 720 }
            };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                videoElement.srcObject = stream;
                videoElement.addEventListener("loadeddata", () => {
                    videoElement.play();

                    // Start Game Loop if not already
                    if (gameState !== 'PLAYING') {
                        // Just ensure loop is running, standard RAF is at bottom
                    }

                    // Initial State Transition if ready
                    if (gameState === 'LOADING' && assetsLoaded && visionLoaded) {
                        gameState = 'MENU';
                        statusText.innerText = "Are you ready?";
                        startInstruction.innerText = 'Press "S" to GAME START';
                        startInstruction.style.display = 'block';
                    }
                });
            });
        };

        // Load assets then start camera
        function loadAssets() {
            let loadedCount = 0;
            const total = Object.keys(IMAGE_SOURCES).length;

            for (let key in IMAGE_SOURCES) {
                const img = new Image();
                img.src = IMAGE_SOURCES[key];
                img.onload = () => {
                    loadedCount++;

                    // Show Progress
                    const percentage = Math.floor((loadedCount / total) * 100);
                    if (!assetsLoaded) {
                        statusText.innerText = `Loading Assets... ${percentage}%`;
                        startInstruction.innerText = `LOADING... ${percentage}%`;
                        startInstruction.style.display = 'block';
                    }

                    if (loadedCount === total) {
                        assetsLoaded = true;
                        console.log("Assets Loaded");
                        checkReady();
                    }
                };
                IMAGES[key] = img;
            }
        }

        function checkReady() {
            if (assetsLoaded && visionLoaded) {
                statusText.innerText = "Allow camera access to play!";
                startInstruction.innerText = "Waiting for Camera...";
                enableWebcam(); // Replaces camera.start()
            }
        }

        loadAssets();

        // --- CALORIE FUNCTIONS ---
        function calculateCalories() {
            const movementCal = totalMoveDistance * CALORIE_CONFIG.PER_PIXEL;
            let poseCal = 0;
            for (let pose in poseDurationMap) {
                const duration = poseDurationMap[pose];
                const intensity = CALORIE_CONFIG.POSE_INTENSITY[pose] || CALORIE_CONFIG.POSE_INTENSITY['DEFAULT'];
                poseCal += duration * intensity;
            }
            return (movementCal + poseCal).toFixed(1);
        }

        function getNextPoseType() {
            if (isTestMode) {
                return GAME_CONFIG.poses[testState.poseIndex];
            } else {
                return GAME_CONFIG.poses[Math.floor(Math.random() * GAME_CONFIG.poses.length)];
            }
        }

        // --- GAME CLASSES ---
        class Wall {
            constructor(specificType = null) {
                this.z = GAME_CONFIG.wallStartZ;

                if (isTestMode) {
                    this.type = specificType || GAME_CONFIG.poses[testState.poseIndex];
                    this.lane = testState.laneOrder[testState.currentLaneIndex];
                    this.color = `hsl(${(testState.poseIndex * 50) % 360}, 70%, 50%)`;
                } else {
                    this.type = specificType || GAME_CONFIG.poses[Math.floor(Math.random() * GAME_CONFIG.poses.length)];
                    this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
                    this.lane = Math.floor(Math.random() * 3) - 1;
                }
                this.laneOffsetNorm = this.lane * -0.3;
            }

            update(dt) {
                this.z -= currentSpeed * (dt / 1000) * 5;
            }

            draw(ctx, width, height) {
                const maxZ = GAME_CONFIG.wallStartZ;
                let progress = 1 - (this.z / maxZ);
                if (progress < 0) progress = 0;
                if (progress > 1) progress = 1;

                const img = IMAGES[this.type];
                if (!img) return;

                const imgW = img.naturalWidth || img.width;
                const imgH = img.naturalHeight || img.height;
                if (imgW === 0 || imgH === 0) return;

                const scaleW = width / imgW;
                const scaleH = height / imgH;
                const baseScale = Math.min(scaleW, scaleH);
                const finalScale = baseScale * progress;

                const drawW = imgW * finalScale;
                const drawH = imgH * finalScale;

                const laneScreenOffset = (width * 0.3) * this.lane;
                const currentOffsetX = laneScreenOffset;

                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.translate(currentOffsetX, 0);
                ctx.globalAlpha = GAME_CONFIG.wallOpacity;

                if (IMAGES[this.type]) {
                    ctx.drawImage(IMAGES[this.type], -drawW / 2, -drawH / 2, drawW, drawH);
                }

                ctx.globalAlpha = 1.0;
                ctx.restore();

                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.translate(currentOffsetX, 0);
                ctx.scale(-progress, progress);

                ctx.fillStyle = "white";
                ctx.font = "bold 40px Arial";
                ctx.textAlign = "center";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 4;

                const fullSizeH = imgH * baseScale;
                const textY = -fullSizeH / 2 - 50;

                ctx.fillText(this.targetPoseName(this.type), 0, textY);
                ctx.restore();
            }

            targetPoseName(type) {
                switch (type) {
                    case 'Y': return "Y-POSE!";
                    case 'I': return "I-POSE!";
                    case 'SQUAT': return "SQUAT DOWN!";
                    case 'X': return "X-POSE!";
                    case 'T': return "T-POSE!";
                    case 'FLAMINGO': return "FLAMINGO!";
                    case 'SUMO': return "SUMO!";
                    case 'KICK': return "KICK!";
                    default: return "";
                }
            }
        }

        function checkCollision(wall, landmarks) {
            const nose = landmarks[0];
            const lWrist = landmarks[15];
            const rWrist = landmarks[16];
            const lShoulder = landmarks[11];
            const rShoulder = landmarks[12];
            const lHip = landmarks[23];
            const rHip = landmarks[24];

            // --- 1. LANE CHECK ---
            const hipCenterX = (lHip.x + rHip.x) / 2;
            const targetX = 0.5 + (wall.lane * 0.3);

            if (Math.abs(hipCenterX - targetX) > 0.15) {
                return false;
            }

            // --- 2. POSE CHECK ---
            if (wall.type === 'Y') {
                const handsUp = lWrist.y < nose.y && rWrist.y < nose.y;
                return handsUp;
            }
            else if (wall.type === 'I') {
                const handsDown = lWrist.y > (lHip.y - 0.1) && rWrist.y > (rHip.y - 0.1);
                const handsIn = Math.abs(lWrist.x - lHip.x) < 0.25 && Math.abs(rWrist.x - rHip.x) < 0.25;
                return handsDown && handsIn;
            }
            else if (wall.type === 'SQUAT') {
                return nose.y > 0.4;
            } else if (wall.type === 'X') {
                const handsUp = lWrist.y < nose.y && rWrist.y < nose.y;
                const shoulderWidth = Math.abs(lShoulder.x - rShoulder.x);
                const wristWidth = Math.abs(lWrist.x - rWrist.x);
                const lAnkle = landmarks[27];
                const rAnkle = landmarks[28];
                const ankleWidth = Math.abs(lAnkle.x - rAnkle.x);
                return handsUp && (wristWidth > shoulderWidth * 0.8) && (ankleWidth > shoulderWidth * 0.8);
            } else if (wall.type === 'T') {
                const yDiff = Math.abs(lWrist.y - lShoulder.y) < 0.15 && Math.abs(rWrist.y - rShoulder.y) < 0.15;
                const shoulderWidth = Math.abs(lShoulder.x - rShoulder.x);
                const wristWidth = Math.abs(lWrist.x - rWrist.x);
                return yDiff && (wristWidth > shoulderWidth * 2.0);
            } else if (wall.type === 'FLAMINGO') {
                const lAnkle = landmarks[27];
                const rAnkle = landmarks[28];
                const diff = Math.abs(lAnkle.y - rAnkle.y);
                return diff > 0.1;
            } else if (wall.type === 'SUMO') {
                const lAnkle = landmarks[27];
                const rAnkle = landmarks[28];
                const lKnee = landmarks[25];
                const rKnee = landmarks[26];
                const shoulderWidth = Math.abs(lShoulder.x - rShoulder.x);
                const ankleWidth = Math.abs(lAnkle.x - rAnkle.x);
                const squatDepth = Math.min(Math.abs(lHip.y - lKnee.y), Math.abs(rHip.y - rKnee.y));
                return (ankleWidth > shoulderWidth * 1.5) && (squatDepth < 0.3);
            } else if (wall.type === 'KICK') {
                const lAnkle = landmarks[27];
                const rAnkle = landmarks[28];
                const lHip = landmarks[23];
                const footHigh = (lAnkle.y < lHip.y + 0.1) || (rAnkle.y < rHip.y + 0.1);
                return footHigh;
            }
            return false;
        }

        Math.dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

        function drawLaneMarker(ctx, w, h, lane) {
            const offsetNorm = lane * 0.3;
            const x = w / 2 + (w * offsetNorm);
            const y = h - 50;

            ctx.save();
            ctx.fillStyle = "yellow";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 30, y + 30);
            ctx.lineTo(x + 30, y + 30);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.scale(-1, 1);
            ctx.textAlign = "center";
            ctx.fillText("STAND HERE", -x, -(y + 40));
            ctx.restore();
        }

        // --- GAME PLAY FUNCTIONS ---

        function triggerEffect(result) {
            if (result === 'clear') {
                effectState.type = 'clear';
                effectState.timer = EFFECT_DURATION;
                effectState.shakeIntensity = 0;
                playSound('success');

                if (currentWall) {
                    sendLog({
                        type: 'event',
                        event: 'clear',
                        pose: currentWall.type,
                        lane: currentWall.lane,
                        score: score,
                        level: currentSpeed
                    });
                }

                currentSpeed += GAME_CONFIG.speedIncrement;
                if (isTestMode && currentSpeed > 10.0) {
                    currentSpeed = 10.0;
                }

            } else {
                effectState.type = 'miss';
                effectState.timer = EFFECT_DURATION;
                effectState.shakeIntensity = 20;
                if (currentWall) {
                    sendLog({
                        type: 'event',
                        event: 'miss',
                        pose: currentWall.type,
                        lane: currentWall.lane,
                        lives: lives,
                        level: currentSpeed
                    });
                }
            }
        }

        function drawEffectsAndUI(ctx, width, height) {
            if (effectState.timer > 0) {
                ctx.save();
                let alpha = (effectState.timer / EFFECT_DURATION) * 0.6;
                if (effectState.type === 'clear') {
                    ctx.fillStyle = `rgba(0, 255, 100, ${alpha})`;
                } else {
                    ctx.fillStyle = `rgba(255, 50, 50, ${alpha})`;
                }
                ctx.fillRect(0, 0, width, height);

                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "italic 900 100px Arial";
                ctx.lineWidth = 5;
                ctx.strokeStyle = "white";

                if (effectState.type === 'clear') {
                    ctx.fillStyle = "#00cc44";
                    ctx.strokeText("COOL!", width / 2, height / 2);
                    ctx.fillText("COOL!", width / 2, height / 2);
                } else {
                    ctx.fillStyle = "#cc0000";
                    ctx.strokeText("MISS...", width / 2, height / 2);
                    ctx.fillText("MISS...", width / 2, height / 2);
                }

                ctx.restore();
                effectState.timer--;
                if (effectState.shakeIntensity > 0) effectState.shakeIntensity *= 0.9;
            }

            if (subState === 'WAIT') {
                ctx.save();

                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "white";
                ctx.font = "bold 60px Arial";
                ctx.shadowColor = "black";
                ctx.shadowBlur = 10;

                let timeLeft = Math.ceil(spawnTimer / 1000);
                if (timeLeft > 0) {
                    ctx.fillText(`NEXT WALL IN ${timeLeft}...`, width / 2, height / 3);
                } else {
                    ctx.fillText("READY?", width / 2, height / 3);
                }

                ctx.font = "bold 30px Arial";
                ctx.fillText(`LEVEL: ${currentSpeed.toFixed(1)}`, width / 2, height / 3 + 60);

                ctx.restore();
            }
        }

        // --- MAIN LOOP ---
        function gameLoop(timestamp) {
            const dt = timestamp - lastTime || 0;
            lastTime = timestamp;

            // Resize
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            const w = canvasElement.width;
            const h = canvasElement.height;

            // --- DETECT POSE ---
            if (poseLandmarker && videoElement.currentTime !== lastVideoTime && videoElement.videoWidth > 0) {
                lastVideoTime = videoElement.currentTime;
                const poseResult = poseLandmarker.detectForVideo(videoElement, timestamp);

                // --- LARGEST SKELETON PRIORITY LOGIC ---
                // "results.landmarks" is Array of Arrays (one per person)
                if (poseResult.landmarks && poseResult.landmarks.length > 0) {
                    let maxArea = -1;
                    let maxIndex = -1;

                    for (let i = 0; i < poseResult.landmarks.length; i++) {
                        const landmarks = poseResult.landmarks[i];
                        let minX = 1.0, maxX = 0.0, minY = 1.0, maxY = 0.0;

                        // Simple Bounding Box
                        landmarks.forEach(lm => {
                            if (lm.x < minX) minX = lm.x;
                            if (lm.x > maxX) maxX = lm.x;
                            if (lm.y < minY) minY = lm.y;
                            if (lm.y > maxY) maxY = lm.y;
                        });

                        const area = (maxX - minX) * (maxY - minY);
                        if (area > maxArea) {
                            maxArea = area;
                            maxIndex = i;
                        }
                    }

                    // Filter to only the largest
                    if (maxIndex !== -1) {
                        latestResults = {
                            poseLandmarks: poseResult.landmarks[maxIndex],
                            poseWorldLandmarks: poseResult.worldLandmarks[maxIndex] // Also take world landmarks if available
                        };
                    }
                } else {
                    latestResults = null;
                }
            }


            // --- SHAKE LOGIC START ---
            canvasCtx.save();
            if (effectState.timer > 0 && effectState.shakeIntensity > 0) {
                const dx = (Math.random() - 0.5) * effectState.shakeIntensity;
                const dy = (Math.random() - 0.5) * effectState.shakeIntensity;
                canvasCtx.translate(dx, dy);
            }

            // Clear
            canvasCtx.clearRect(0, 0, w, h);

            // Draw Video (Mirrored context)
            canvasCtx.save();
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-w, 0);
            if (videoElement.readyState >= 2) { // HAVE_CURRENT_DATA
                canvasCtx.drawImage(videoElement, 0, 0, w, h);
            }
            canvasCtx.restore();

            // Draw Skeleton
            canvasCtx.save();
            canvasCtx.scale(-1, 1);
            canvasCtx.translate(-w, 0);
            if (latestResults && latestResults.poseLandmarks) {
                if (drawingUtils) {
                    // Use new DrawingUtils
                    // It expects landmarks as normalized 0-1
                    // Options for style
                    const CONNECTIONS = POSE_CONNECTIONS;
                    drawingUtils.drawConnectors(latestResults.poseLandmarks, CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                    drawingUtils.drawLandmarks(latestResults.poseLandmarks, { color: '#FF0000', lineWidth: 2, radius: 3 });
                }
            }
            canvasCtx.restore();

            // --- CALORIE TRACKING (NOSE MOVEMENT) ---
            if (gameState === 'PLAYING' && latestResults && latestResults.poseLandmarks) {
                const nose = latestResults.poseLandmarks[0];
                const currentNoseXPx = nose.x * w;

                if (lastNoseX !== null) {
                    const dist = Math.abs(currentNoseXPx - lastNoseX);
                    totalMoveDistance += dist;
                }
                lastNoseX = currentNoseXPx;

                if (nextPoseType) {
                    if (!poseDurationMap[nextPoseType]) poseDurationMap[nextPoseType] = 0;
                    poseDurationMap[nextPoseType] += (dt / 1000);
                }
            }

            // --- GAME LOGIC ---
            if (gameState === 'PLAYING') {
                canvasCtx.save();
                canvasCtx.scale(-1, 1);
                canvasCtx.translate(-w, 0);

                if (subState === 'WAIT') {
                    spawnTimer -= dt;
                    if (spawnTimer <= 0) {
                        subState = 'ACTION';
                        currentWall = new Wall(nextPoseType);

                        if (isTestMode) {
                            testState.poseIndex++;
                            if (testState.poseIndex >= GAME_CONFIG.poses.length) {
                                testState.poseIndex = 0;
                                testState.currentLaneIndex++;
                                if (testState.currentLaneIndex >= testState.laneOrder.length) {
                                    testState.currentLaneIndex = 0;
                                }
                            }
                        }
                    }
                }
                else if (subState === 'ACTION') {
                    if (currentWall) {
                        currentWall.update(dt);
                        currentWall.draw(canvasCtx, w, h);
                        drawLaneMarker(canvasCtx, w, h, currentWall.lane);

                        if (currentWall.z <= 0) {
                            let success = false;
                            if (latestResults && latestResults.poseLandmarks) {
                                success = checkCollision(currentWall, latestResults.poseLandmarks);
                            }

                            if (success) {
                                score++;
                                scoreDisplay.innerText = "SCORE: " + score;
                                triggerEffect('clear');
                            } else {
                                lives--;
                                updateLives();
                                triggerEffect('miss');
                                if (lives <= 0) {
                                    gameOver();
                                }
                            }

                            currentWall = null;
                            subState = 'WAIT';
                            spawnTimer = GAME_CONFIG.spawnInterval;
                            nextPoseType = getNextPoseType();
                        }
                    }
                }
                canvasCtx.restore();
            }

            drawEffectsAndUI(canvasCtx, w, h);
            canvasCtx.restore();

            requestAnimationFrame(gameLoop);
        }

        function updateLives() {
            let s = "";
            for (let i = 0; i < lives; i++) s += "‚ù§Ô∏è";
            livesDisplay.innerText = s;
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            messageOverlay.style.display = 'block';
            titleText.innerText = "GAME OVER";
            const kcal = calculateCalories();
            statusText.innerHTML = `Final Score: ${score}<br><span style="font-size: 0.8em; color: #ffcc00;">Est. Calories: ${kcal} kcal</span>`;
            startInstruction.innerText = 'Press "S" to TRY AGAIN';
            startInstruction.style.display = 'block';

            sendLog({
                type: 'game_over',
                score: score,
                level: currentSpeed
            });
        }

        function startGame() {
            score = 0;
            lives = 3;
            currentSpeed = GAME_CONFIG.initialSpeed;
            spawnTimer = 2000;

            if (isTestMode) {
                testState.currentLaneIndex = 0;
                testState.poseIndex = 0;
            }

            totalMoveDistance = 0;
            poseDurationMap = {};
            lastNoseX = null;

            nextPoseType = getNextPoseType();

            scoreDisplay.innerText = "SCORE: " + score;
            updateLives();
            messageOverlay.style.display = 'none';

            gameState = 'PLAYING';
            subState = 'WAIT';

            playSound('bgm-start');
        }

        requestAnimationFrame(gameLoop);

    </script>
</body>

</html>