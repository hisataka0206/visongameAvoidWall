
# 脳カベ風ポーズゲーム 仕様書（整理版）

## 0. ゴール / 全体像

Webカメラを使い、テレビ番組の「脳カベ（Hole in the Wall）」のようなゲームを作成する。

* 迫ってくる壁に空いた「穴」の形に合わせてポーズをとる
* 壁にぶつからずにすり抜けられたら成功
* HTML5 Canvas + JavaScript + MediaPipe Pose（CDN）
* **単一HTMLファイル（index.html）で完結**

---

## 1. 技術スタック・前提条件

### 1.1 使用技術

* HTML5
* JavaScript
* HTML5 Canvas
* MediaPipe Pose（CDN経由）

### 1.2 実行条件

* PCの内蔵カメラを使用
* ブラウザ上で動作（追加ビルド不要）

---

## 2. 操作・コントロール

* **Sキー**: ゲームスタート（タイトル画面・ゲームオーバー画面）
* **Tキー**: テストモード切り替え（ポーズ順序の固定化など）

---

## 3. 音響（Audio）仕様

* **BGM**: 実装枠あり（現在はプレースホルダー）
* **SE（効果音）**: Web Audio APIを使用
  * **Success**: 成功時の上昇音
  * **Crash**: 失敗（衝突）時のノイズ音

---

## 4. カメラ・ポーズ検出仕様

### 4.1 カメラ入力

* PC内蔵カメラ映像を取得
* 画面全体に表示
* **必ず左右反転（ミラーリング）**
  → 鏡のように直感的に動けるようにする

### 4.2 ポーズ検出

* MediaPipe Pose を使用
* 全身ランドマークをリアルタイム検出

### 4.3 デバッグ表示

* 検出した骨格（スケルトン）を
  * カメラ映像の上に
  * 細い線でオーバーレイ表示

---

## 5. 画面レイヤー構成

1. **最下層**：カメラ映像
2. **中間層**：スケルトン（デバッグ）
3. **最上層**：Canvas（ゲームUI）

Canvas上に描画する要素：

* 壁
* 穴
* スコア
* ライフ
* カウントダウン
* エフェクト

---

## 6. ゲーム進行・ステート設計

### 6.1 ゲームの基本フロー

1. スタートボタンで開始（キーボードのSを押下）
2. 指定ポーズをランダム選択
3. 壁が奥から手前へ迫ってくる
4. 通過タイミングで判定
5. 成功 or 失敗
6. 次の壁へ（またはゲームオーバー）

---

### 6.2 ゲームステート（ステートマシン）

#### ① Wait フェーズ

* 次の壁が出るまでの待機時間
* 表示例：
  * 「Next Wall in 3...2...1...」
  * または「Ready?」

#### ② Action フェーズ

* 壁生成
* 壁が迫ってくるアニメーション

#### ③ Result フェーズ

* 判定結果を表示（〇 / ×）
* エフェクト再生

→ 再び Wait フェーズへ戻る

---

## 7. 壁・アニメーション仕様

### 7.1 壁表現

* 3Dではなく **2D表現**
* 中央から拡大してくるような表現
* 穴以外の部分は
  * デフォルト半透明の赤色などで塗りつぶし
  * 「ここにはみ出したらアウト」を明示
* /wallディレクトリに置かれている各ポーズの穴についてのpng画像を読み込み、迫ってくる壁として使うこと
* デフォルトはwall50.png
* IポーズはwallI50tr.png
* フラミンゴポーズはwallFlamingo50tr.png
* squatポーズはwallSquat50tr.png
* sumoポーズはwallSumo50tr.png
* kickポーズはwallKick50tr.png
* TポーズはwallT50tr.png
* XポーズはwallX50tr.png
* YポーズはwallY50tr.png
* 縦横比については、ベースとなる画像の縦横比を守ってください。
* 拡縮については、最小はゼロ、最大で画面サイズとなるようにしてください。

* /wallディレクトリに置かれているwall50.pngの半透明を使って全体を塗り潰すこと

### 7.2 壁スピード

* ステージが進むごとに加速
* 最大速度あり

---

## 8. 判定仕様（共通ルール）

### 8.1 判定タイミング（重要）

* 常時判定しない
* **壁が最も手前に来た瞬間のみ**
* 数フレームだけ判定を有効にする

```js
judgementFrameCount
```

* 判定の瞬間に画面フラッシュなどの演出を入れる

---

### 8.2 判定構成

1. **位置合わせ判定（X軸）**
2. **ポーズ判定（形状）**

※ 位置がズレていた場合
→ ポーズが合っていても即 MISS

---

## 9. 初期ポーズ（基本3種）

### 9.1 ポーズA：バンザイ（Yポーズ）

* **壁形状**：Y字型の穴
* **判定条件**
  * 左右手首のY座標が鼻より上
  * 両手首のX座標が肩より外側


---

### 9.2 ポーズB：気をつけ（Iポーズ）

* **壁形状**：I字型の細長い穴
* **判定条件**
  * 左手首と左腰が近い
  * 右手首と右腰が近い

---

### 9.3 ポーズC：しゃがむ（Squat）

* **壁形状**：下半分のみ穴
* **判定条件**
  * 鼻のY座標が画面中央より下

---

## 10. 追加ポーズ（上半身・バランス系）

### 10.1 X（エックス）

* **壁形状**：X字型
* **判定条件**
  * 両手首が鼻より上
  * 両手首X距離が広い
  * 両足首X距離 > 肩幅

---

### 10.2 T（ティー）

* **壁形状**：T字型
* **判定条件**
  * 手首Y ≒ 肩Y（許容誤差あり）
  * 手首Xが体中心から十分離れている

---

### 10.3 フラミンゴ（片足立ち）

* **壁形状**：下半分が一本足
* **判定条件**
  * 片方の足首Yがもう片方より有意に高い
  * 左右どちらでもOK

---

## 11. 足強化・全身運動仕様

### 11.1 壁出現位置ランダム化（サイドステップ）

#### レーン仕様

* 左・中央・右 の3レーン
* 例：画面幅 30% / 50% / 70%

#### 判定ルール

* 壁の offsetX を基準に
* プレイヤーの **腰（Hips）中心X** が合っているか判定
* 合っていなければ即 MISS

#### 視覚ガイド

* 画面下部に
  * 「STAND HERE」
  * 矢印・枠線マーカー

---

### 11.2 下半身強化ポーズ

#### A. SUMO（四股）

* **壁形状**：横に広く低い穴
* **判定条件**
  * 足首X距離 ≥ 肩幅×2
  * 腰Yが明らかに低い
  * 手は膝 or 腰付近

---

#### B. KICK（サイドキック）

* **壁形状**：片足だけ横に出た穴
* **判定条件**
  * 片足首Yが腰付近まで上がる
  * 軸足は地面
  * 判定は甘め

---

## 12. UIデザイン

### 12.1 表示要素

* スコア：左上・大きく表示
* ライフ：ハート表示（例：3）
* 現在速度（レベル）
* 次の壁までのカウントダウン

### 12.2 雰囲気

* バラエティ番組風
* コミカル＋緊迫感

---

## 13. エフェクト仕様

### 13.1 エフェクト状態管理

```js
let effectState = {
  type: null,
  timer: 0,
  shakeIntensity: 0
};
const EFFECT_DURATION = 30;
```

---

### 13.2 判定時の発火

#### 成功時

* type = 'clear'
* timer = EFFECT_DURATION

#### 失敗時

* type = 'miss'
* timer = EFFECT_DURATION
* shakeIntensity = 20

---

### 13.3 描画処理

#### A. 画面シェイク（失敗時）

* ctx.translate() を使用
* shakeIntensity は徐々に減衰

#### B. フラッシュ

* 成功：緑（rgba(0,255,100,0.5)）
* 失敗：赤（rgba(255,50,50,0.6)）

#### C. テキスト

* 成功：「COOL!」「PERFECT!」
* 失敗：「MISS...」「CRASH!」
* 大きくインパクト重視

#### D. タイマー更新

* 毎フレーム timer--
* 0でリセット

---

## 14. ゲームバランス設定（Config）

```js
const GAME_CONFIG = {
  initialSpeed: 5.0,
  // maxSpeed: (Unlimited),
  speedIncrement: 1.0,
  spawnInterval: 2000,
  judgementFrameCount: 5,
};
```

---

## 15. 難易度曲線

* 初期：ゆっくり（練習）
* クリアごとに speedIncrement (1.0) 加速
* maxSpeed は設定せず無制限に加速（実質的な限界はあるが設定値としてはUnlimited）
* 後半は反射神経ゲーム

---

## 16. エラーハンドリング

* カメラ未許可時：アラート表示
* MediaPipeロード中：
  * ローディング画面表示
  * 完了後にスタートボタン有効化
* フレームアウト時：
  * 「もっと下がって！」等の警告UI

---

## 17. PoC調査

* PoCの調査を行うためにユーザーのログをGAS上に記載するようにしたい。
GASのアドレスはこちら。
https://script.google.com/macros/s/AKfycbxeJqv6X1k6V3o9HkMGSe7I-Td0F0ry8MgN3_NtLkEn1aYfapXYND5nUYl8PCamvu8ANA/exec

* GASにどのキーを打ったのかを記載されるように以下のコードを参考にindex.htmlを修正してください。
// ▼ ゲームごとにここを変える
const GAME_NAME = "AvoidWall_v1"; 

// ... (SESSION_IDなどはそのまま) ...

function sendKeyLog(keyName, note = "") {
    fetch(GAS_URL, {
        // ... (省略) ...
        body: JSON.stringify({
            gameName: GAME_NAME, // ▼ ここでゲーム名を送信！
            key: keyName,
            note: note,
            session: SESSION_ID 
        })
    });
}

* ゲーム完了時点のスコアやどの位置・ポーズをクリアしたのか、どの位置・ポーズを失敗したのかをGASに記載させる様にindex.htmlを修正してください。
* 誤操作を特定したいです。画面上の指示とは異なるキー操作が行われた場合には、補足情報として記入するようにしたい

## 18. カロリー計算仕様
ゲーム終了（Game Over または Clear）時に、プレイヤーの運動量に基づいた「推定消費カロリー」を算出し、リザルト画面に表示する。

算出は「移動距離」と「ポーズ維持時間」を加算する。

### 18-1. データ要件（トラッキング変数）
ゲームループ（update関数内）にて、以下の変数をリアルタイムに更新・保持すること。
変数名型説明更新タイミングtotal_move_distanceFloatプレイヤーの鼻(Nose)のX座標の移動量累積値（ピクセル単位）abs(current_x - prev_x)を加算。毎フレームpose_duration_mapDictionary各ポーズごとの維持時間を記録するマップ。例: {"squat": 12.5, "y_pose": 5.0, ...}壁待ち状態中（毎フレーム delta_timeを加算）perfect_countInteger判定が「Perfect」だった回数。壁通過判定時total_wall_countInteger通過した壁の総数。壁通過判定時

### 18-2. 定数定義（係数設定）カロリー計算に使用する係数

* 係数は標準体型成人のMETs値を参考にしたゲーム内推定値）。

* 移動係数CALORIE_PER_PIXEL: 0.0005 kcal/px補足: 画面幅(例:1920px)を端から端まで2往復程度して約2kcal消費する想定。壁をクリア時に人は常に中央に戻る事を想定し、毎回加算する。
* ポーズ強度係数 (CALORIE_PER_SEC)ポーズごとの1秒あたりの消費カロリー。カテゴリ該当ポーズ係数 (kcal/sec)高強度Squat (しゃがむ), Sumo (四股)0.12中強度SideKick (キック), Flamingo (片足立ち), Y_Pose (バンザイ), T_Pose0.08低強度I_Pose (気をつけ), その他デフォルト0.05


### 18-3. 算出ロジック
ゲーム終了処理（show_result等）にて以下の計算を行う。
Python(JSロジックの概要)
function calculate_calories():
    # 1. 移動による消費
    # totalMoveDistance(px) * 0.0005 kcal/px
    movement_cal = totalMoveDistance * CALORIE_CONFIG.PER_PIXEL

    # 2. ポーズ維持による消費
    # 各ポーズの維持時間(秒) * ポーズ強度係数
    for pose in poseDurationMap:
        pose_cal += duration * GET_POSE_INTENSITY(pose)

    # 3. 基礎合計
    base_total = movement_cal + pose_cal

    # 4. 表示用に整形（小数点第1位など）
    return base_total.toFixed(1)

### 18-4. UI表示仕様表示タイミング
ゲーム終了時のリザルト画面（スコア表示の近く）。表示テキスト:日本語: 燃焼カロリー: 約 {cal} kcal